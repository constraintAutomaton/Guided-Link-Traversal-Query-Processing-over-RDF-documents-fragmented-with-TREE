<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">How TREE hypermedia can speed up Link Traversal-based Query Processing for SPARQL queries with filters</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" media="all"    href="styles/katex.css" />
  <meta name="citation_title" content="How TREE hypermedia can speed up Link Traversal-based Query Processing for SPARQL queries with filters">
  <meta name="citation_author" content="Bryan-Elliott Tam" />
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Pieter Colpaert" />
  
  <meta name="citation_publication_date" content="2023/03/14" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <!-- Guided Link Traversal Query Processing over RDF documents fragmented with TREE -->
<header>
  <h1 id="how-tree-hypermedia-can-speed-up-link-traversal-based-query-processing-for-sparql-queries-with-filters">How TREE hypermedia can speed up Link Traversal-based Query Processing for SPARQL queries with filters</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/constraintAutomaton" typeof="foaf:Person schema:Person" resource="">Bryan-Elliott Tam</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://pietercolpaert.be/" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me">Pieter Colpaert</a></li>
  </ul>

  <ul id="affiliations">
    <li id="myaffiliation">IDLab, Department of Electronics and Information Systems, Ghent University – imec</li>
  </ul>

</header>
<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>Linked Data can be published on the Web in a variety of APIs such as in subject pages or in a SPARQL endpoint.
Each API has its own set of trade-offs:
in the former, the client needs to perform a rather slow link traversal algorithm to find an answer to any query, but the 
API is cheap to host; while in the latter the server is able to provide a rather fast and concise answer to a 
well-defined query, but the API is more expensive to maintain. 
<!-- Need         -->
An in-between solution could work using guided link traversal and hypermedia, in which the server already exposes hints 
of an ordering of subjects in a search space.
<!-- Task         -->
The <a href="https://w3id.org/tree/specification">TREE hypermedia specification</a> allows to define such relations between pages (fragments) containing zero or more members of the collection.
<!-- Object       -->
In this paper, we investigate a Guided Link Traversal-based Query Processing (GLTQP) approach to search through such 
interlinked fragments, and reduce the number of fragments that need to be visited by taking into account the described relations.
<!-- Findings     -->
Our findings show that we are able to use the hypermedia descriptions of the TREE specification to prune links to 
fragments that will certainly not contribute to the SPARQL query based on a reachability criteria that can be
the basis for a solver resolving a boolean equation combinaing the SPARQL FILTER expression and TREE Relation descriptions.
<!-- Conclusion   -->
This solver has been made available as open-source as part of the Comunica project to demonstrate how it can generate faster results on the client for 
SPARQL queries with FILTER clauses over TREE fragmented Linked Datasets.</p>

    </div>
</section>

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p>Hosting a number of RDF documents is a cost-efficient choice when it comes to Web API design.
One alternative would be to host a SPARQL endpoint, that can generate an infinite amount of RDF documents depending on the precise SPARQL query.
The data publisher however can also publish its data in fragments with a certain locality,
which can lead to an interesting new trade-off between cost-efficiency and query execution when the client takes part in the query execution,
as demonstrated by the work on Triple Pattern Fragments <span class="references">[<a href="#ref-1">1</a>]</span>.
The fragmentation helps the users by giving them the possibility to fetch only the relevant data subsets.</p>

        <p>By storing pre-processed data into fragments in various ways, client-side applications can reduce computational load during other tasks as well, like auto completion <span class="references">[<a href="#ref-2">2</a>]</span> and client-side route planning <span class="references">[<a href="#ref-3">3</a>]</span>.
The disadvantage of fragmenting such datasets is that there are multiple data sources that the user
has to query to find the information needed, which means more HTTP lookups,
hence a potential higher client side query execution time. 
In this paper, we consider the following use case;
a user wants to determine the temperature of all sensor logs that have been created before or at the first of January 2023,
which can be expressed in SPARQL as shown in <a href="#example-sparql">Listing 1</a>.</p>

        <div class="sidebysidecontainer" style="align-items: stretch !important; ">
<figure id="example-sparql" class="listing" style="padding-right: 5px; padding-left: 5px; height='100%'">
<pre><code>PREFIX sosa: &lt;http://www.w3.org/ns/sosa/&gt; 
</code><code>PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; 
</code><code>
</code><code>SELECT ?s ?temp
</code><code>WHERE {
</code><code>  ?s sosa:resultTime ?t;
</code><code>     sosa:hasSimpleResult ?temp.
</code><code>
</code><code>  FILTER(?t &lt;= &quot;2023-01-01T00:00:00Z&quot;^^xsd:dateTime)
</code><code>}
</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> SPARQL query to get the temperature and the associated unit IRI.</p>
            </figcaption>
</figure>

<figure id="TREE-relation-turtle-example" class="listing" style="padding-right: 5px; padding-left: 5px">
<pre><code>@prefix tree: &lt;https://w3id.org/tree#&gt; .
</code><code>@prefix sosa: &lt;http://www.w3.org/ns/sosa/&gt; .
</code><code>@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
</code><code>@prefix ex: &lt;https://example.be/&gt; .
</code><code>
</code><code>ex:node tree:relation _:b1 .
</code><code>_b1 a  tree:EqualToRelation ;
</code><code>    tree:node ex:nextNode ;
</code><code>    tree:value &quot;2023-01-07T00:00:00Z&quot;^^xsd:dateTime ;
</code><code>    tree:path sosa:resultTime ;
</code><code>    tree:remainingItems &quot;21&quot;^^xsd:integer .</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> The example is showing a set of triples representing a TREE relation. 
The relation can be converted into the following boolean equation 
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">(</mo><mtext>2023-01-07T00:00:00Z</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x= unitTime(\text{2023-01-07T00:00:00Z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord text"><span class="mord">2023-01-07T00:00:00Z</span></span><span class="mclose">)</span></span></span></span> 
where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is any variable inside the client SPARQL query that as the predicate <code>sosa:resultTime</code>.</p>
            </figcaption>
</figure>
</div>

        <p>As there are too many sensor logs for one page, the data provider decides
to fragment the dataset using the <a href="https://w3id.org/tree/specification">TREE specification</a>.
TREE enables data publishers to place a boolean constraint on a property of the members inside each fragment.
Furthermore, these fragments linked to each other with a hypermedia description of the constraint.</p>

        <p>Given these hypermedia-based constraints,
it is therefore possible for a client-side query engine
to interpret those constraints and use them during SPARQL query execution.
Furthermore, the engine could map the constraints to SPARQL FILTER expressions,
and only fetch those fragments that could contribute to query results.</p>

        <p>One approach to achieve this, is to apply a query paradigm called
Guided Link Traversal Query Processing (GLTQP) <span class="references">[<a href="#ref-4">4</a>]</span>
a specific form of Link Traversal Query Processing (LTQP) <span class="references">[<a href="#ref-5">5</a>]</span>.
The idea of LTQP consists of recursively looking up new documents
by following links inside them.
GLTQP goes a step further,
by making use of a priori knowledge pertaining to the structure of Linked Data documents and 
knowledge captured during the query execution to reduce the search domain.</p>

      </div>
</section>

  <section id="guided_link_traversal" inlist="" rel="schema:hasPart" resource="#guided_link_traversal">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Guided Link traversal for the TREE specification</h2>

        <p>The objective of GLTQP is to reduce the search domain of a query engine by selecting data sources based on knowledge 
acquired before or during execution.
Our approach to GLTQP consists of restricting the links 
that the query engine can follow using a combination of prior knowledge about the structural properties of the TREE specification,
and the hypermedia descriptions <span class="references">[<a href="#ref-6">6</a>]</span> of fragment constraints.</p>

        <p>More formally, this consists of creating a reachability criterium <span class="references">[<a href="#ref-7">7</a>]</span> 
that can discriminate triples encountered
inside a TREE document with the objective to decide if dereferencing the URLs in
those triples will contribute to the results for the query.
A conceptual example is presented at <a href="#running_example">Fig. 1</a> based on the query of <a href="#example-sparql">Listing 1</a>,
where we see in green that the query engine only considers the triples pertaining to
the relation between the fragment and follow the relation that is compatible with the SPARQL filter expression.</p>

        <figure id="running_example">
<img src="img/running_example.drawio.svg" alt="[Running example of our GLTQP approach]" class="figure-narrow" style="height: 20vh" />
<figcaption>
            <p><span class="label">Fig. 1:</span> Running example of our GLTQP approach based on <a href="#example-sparql">Listing 1</a>.</p>
          </figcaption>
</figure>

        <p>To determine if a URL will lead to another fragment in the current TREE dataset,
or another document elsewhere on the Web,
we need to consider the structural aspects of the TREE specification.
Concretely, fragments of TREE datasets
are called <a href="https://treecg.github.io/specification/#Node"><code>tree:Node</code></a>s.
Those fragments contain hypermedia descriptions of the next <code>tree:Node</code>s that are related to this node.
Those descriptions are called <a href="https://treecg.github.io/specification/#Relation"><code>tree:Relation</code></a>,
they characterize the link between the current <code>tree:Node</code> and another via the predicate <code>tree:node</code>.
An example of the descriptions of such a TREE dataset is shown 
in <a href="#TREE-relation-turtle-example">Listing 2</a> using the <a href="https://www.w3.org/TR/turtle/">Turtle</a> serialization.</p>

        <p>The second part of our reachability criterium pertains to the compatibility between the constraint
of the <code>tree:Node</code> and the SPARQL Filter expression. 
The constraint of the <code>tree:Relation</code>, can be conceptualized as a boolean equation.
This equation has a variable, a comparator and a literal,
we can exemplify it by the following simple expression; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>&#x2264;</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>x</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">(</mo><mtext>2023-01-07T00:00:00Z</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \leq unixTime(\text{2023-01-07T00:00:00Z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&#x2264;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord text"><span class="mord">2023-01-07T00:00:00Z</span></span><span class="mclose">)</span></span></span></span>.
The left hand of the expression, the variable, is contingent to a SPARQL query expression.
It is the variable pertaining to the property that the <code>tree:Relation</code> is targeting.
The property targeted by the relation is defined by the object of the triple
having the predicate <code>tree:path</code>.
In the example of <a href="#example-sparql">Listing 1</a> it was <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">?</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">?t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose">?</span><span class="mord mathnormal">t</span></span></span></span>, because the example of <a href="#TREE-relation-turtle-example">Listing 2</a>
has the <code>tree:path</code> property <code>sosa:resultTime</code>. 
The boolean operator such as; equal, greater than, is described by the <a href="https://treecg.github.io/specification/#Relation">RDF type of the TREE relation</a>, in Turtle serialization it is the object of the triple with the predicate “<code>a</code>”.
Finally, the literal is simply represented by the object of the triple in the relation,
containing the predicate <code>tree:value</code>.</p>

        <p>Given the boolean representation of the <code>tree:Relation</code> and the SPARQL filter expression that is already a boolean expression,
a solver can evaluate if the combination of those two expressions is resolvable, like in <a href="https://github.com/constraintAutomaton/comunica-feature-link-traversal/tree/feature/time-filtering-tree-sparqlee-implementation">our open source implementation</a> where we evaluate the solution domain of the equation to find the solvability, hence, pruning certainly non-contributing relations.</p>

      </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusion</h2>

        <p>Concluding from our preliminary implementation, a GLTQP approach to prune links to fragmented RDF documents following the TREE specification based on SPARQL filter expressions is possible.
We show that we can exploit the structural properties of the TREE specification 
and the hypermedia constraints on links between fragments to reduce the search domain
that a LTQP query engine has to explore.</p>

        <p>This work opens the possibility for faster traversal-based query execution over fragmented RDF documents, 
given that the data provider uses hypermedia descriptions to characterize the fragmentation
in a structured manner. 
In future work, we are going to benchmark this GLTQP approach and are going to
empirically prove the efficiency of our method.</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#Verborgh2016TriplePF" typeof="schema:Article">Verborgh, R., Sande, M.V., Hartig, O., Herwegen, J.V., Vocht, L.D., Meester, B.D., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: A low-cost knowledge graph interface for the Web. J. Web Semant.</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#ColpaertMaterializedTREE" typeof="schema:Article">Colpaert, P.: Building materializable querying interfaces with the TREE hypermedia specification.</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#Delva2020" typeof="schema:Article">Delva, H., Rojas, J.A., Vandenberghe, P.-J., Colpaert, P., Verborgh, R.: Geospatial Partitioning of Open Transit Data. In: Web Engineering. Springer</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#verborgh2020" typeof="schema:CreativeWork">Verborgh, R., Taelman, R.: Guided Link-Traversal-Based Query Processing</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="#Hartig2013AnOO" typeof="schema:Article">Hartig, O.: An Overview on Execution Strategies for Linked Data Queries. Datenbank-Spektrum.</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#thomasFieldingPhdThesis" typeof="schema:Thesis">Fielding, R.T.: Architectural Styles and the Design of Network-based Software Architectures</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#hartig2012" typeof="schema:Article">Hartig, O., Freytag, J.-C.: Foundations of Traversal Based Query Execution over Linked Data. In: Conference on Hypertext and Social Media. ACM</dd>
</dl>
</section>
</footer>



</div>

</body>
</html>

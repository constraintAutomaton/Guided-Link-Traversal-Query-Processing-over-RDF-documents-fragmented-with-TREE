<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Exploiting SPARQL Filter Expressions for Link Pruning during Link Traversal Query processing</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" media="all"    href="styles/katex.css" />
  <meta name="citation_title" content="Exploiting SPARQL Filter Expressions for Link Pruning during Link Traversal Query processing">
  <meta name="citation_author" content="Bryan-Elliott Tam" />
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Pieter Colpaert" />
  
  <meta name="citation_publication_date" content="2024/05/02" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="exploiting-sparql-filter-expressions-for-link-pruning-during-link-traversal-query-processing">Exploiting SPARQL Filter Expressions for Link Pruning during Link Traversal Query processing</h1>
  <!-- 
{:#authors}
- <a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/constraintAutomaton" typeof="foaf:Person schema:Person" resource="">Bryan-Elliott Tam</a>
- <a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
- <a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://pietercolpaert.be/" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me">Pieter Colpaert</a>

{:#affiliations}
- {:#myaffiliation} IDLab, Department of Electronics and Information Systems, Ghent University – imec
-->
</header>
<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>Linked data published on the web can naturally be interpreted as one fragmented knowledge graph.
<!-- Need         -->
The query of subgraph has been well studied in the context of single endpoints
and of multiple enpoints in federated queries.
However, in some contexts, it is not possible to know prior to the query execution the location
of those subgraphs.
Those subgraphs can also be linked following logical expressions,
for instance, data published after the first of September is located at this URI.
<!-- Task         -->
We propose to use the concept of structural assumption for publication
and querying of those documents using a lightweight arithmetic solver to discriminate
subgraphs based on the query sent by the user.
This pruning mecanism aims at reducing the query execution time
avoiding costly unnecessary HTTP requests.
<!-- Object       -->
This poster paper presents our strategy and early experimental results.
<!-- Findings     -->
Our preliminary findings show that by using this strategy,
we are able to significantly reduce the number of HTTP requests and the query execution time
when executing queries aligned with the fragmentation of the result.
<!-- Conclusion   -->
Given the promising result of the initial approach,
In the future, 
we aim to extend our solver to support string and geospatial expressions,
to support more general lightweight reasoning and to support the streaming of 
results for queries with filter expression aligned with the data fragmentation and the order of traversal.</p>

    </div>
</section>

<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p><a href="https://lod-cloud.net/#diagram">The increasing amount of available Linked Data on the Web</a>,
prompts the need for efficient query interfaces, with SPARQL endpoints as the most prominent one.
During a typical SPARQL query execution, the interface takes the whole query load and delivers the results to the client.
This may cause high workloads and is partially the reason for having <a property="schema:citation http://purl.org/spar/cito/cites" href="https://doi.org/10.1007/978-3-642-41338-4_18">historically low
availability levels</a> <span class="references">[<a href="#ref-1">1</a>]</span>.
Academics have made efforts to introduce alternative Linked Data publication methods
that enable clients participating in the query execution process.
The goal is to lower server-side workloads and while keeping fast query execution to the client <span class="references">[<a href="#ref-2">2</a>]</span>.
The TREE hypermedia specification is an effort in that direction <span class="references">[<a href="#ref-3">3</a>, <a href="#ref-4">4</a>]</span>,
that introduces the concept of domain-related fragmentation of large RDF datasets.
For example, in the case of periodic measurements of sensor data,
the fragmentation can be made based on the publication date of each data entity.
TREE aims to fragment datasets in a way that enables clients to easily fetch subsets that fully answer a given query.
The data inside a fragment are bounded with constraints that are expressed using hypermedia descriptions <span class="references">[<a href="#ref-5">5</a>]</span>.
More precisely, each fragment declaratively describes the constraints of the data it contains, and links to other fragments.
Since TREE fragments are hyperlinked Linked Data documents,
clients must traverse over these documents to find data,
which makes Link Traversal Query Processing (LTQP) <span class="references">[<a href="#ref-6">6</a>]</span> a suitable technique for answering SPARQL queries over it.</p>

        <p>LTQP typically starts with a set of seed URLs that are dereferenced.
From these dereferenced documents, links to other documents are dereferenced recursively.
So far, applications on top of TREE datasets <span class="references">[<a href="#ref-3">3</a>, <a href="#ref-4">4</a>]</span>
have resorted to custom traversal implementations to find data matching specific data needs.
Our aim in this work is to explore how to execute generic SPARQL queries over TREE datasets through LTQP.
We do not aim to extend the existing TREE specification,
but merely to introduce LTQP-specific link pruning techniques that exploit the structural properties of TREE,
similar to the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2023-SolidQuery/">exploitation of structural properties when performing LTQP over the Solid environment</a> <span class="references">[<a href="#ref-7">7</a>]</span>.
Specifically, we will make use of the SPARQL FILTER expression to prune links that match the constraints of TREE fragments.</p>

        <p>As a running example throughout this paper, we consider the publication of sensor data.
For example, the query in <a href="#example-sparql">Listing 1</a> targets the DAHCC <span class="references">[<a href="#ref-8">8</a>]</span> dataset.
We have created queries to get the measures between a specific time interval (the filter expression will vary in our experiment) 
and information about the sensor using a metadata file, which is available at
<a href="https://github.com/predict-idlab/DAHCC-Sources/blob/main/instantiated_examples/_Homelab.owl">https:/​/​github.com/predict-idlab/DAHCC-Sources/blob/main/instantiated_examples/_Homelab.owl</a></p>

        <div class="sidebysidecontainer" style="align-items: stretch !important; ">
<figure id="example-sparql" class="listing" style="padding-right: 5px; padding-left: 5px; height='100%'">
<pre><code>PREFIX sosa: &lt;http://www.w3.org/ns/sosa/&gt; 
</code><code>PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; 
</code><code>PREFIX wgs: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#&gt;
</code><code>PREFIX etsi: &lt;https://saref.etsi.org/core/&gt;
</code><code>PREFIX dahcc: &lt;https://dahcc.idlab.ugent.be/Ontology/Sensors/&gt;
</code><code>PREFIX saref: &lt;https://saref.etsi.org/core/&gt;
</code><code>
</code><code>SELECT * WHERE {
</code><code>  ?s etsi:hasTimestamp ?t;
</code><code>    etsi:hasValue ?result;
</code><code>    etsi:measurementMadeBy ?sensor.
</code><code>  ?sensor dahcc:analyseStateOf ?stateOf;
</code><code>    saref:measuresProperty {:property}.
</code><code>  
</code><code>  FILTER(?t=&quot;2022-01-03T10:57:54.000000&quot;^^xsd:dateTime)
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> SPARQL query to get sensor measurements and metadata</p>
            </figcaption>
</figure>

<figure id="TREE-relation-turtle-example" class="listing" style="padding-right: 5px; padding-left: 5px">
<pre><code>@prefix tree: &lt;https://w3id.org/tree#&gt; .
</code><code>@prefix sosa: &lt;http://www.w3.org/ns/sosa/&gt; .
</code><code>@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
</code><code>@prefix ex: &lt;https://example.be/&gt; .
</code><code>@prefix etsi: &lt;https://saref.etsi.org/core/&gt;
</code><code>
</code><code>ex:node tree:relation [
</code><code>    a  tree:GreaterThanOrEqualToRelation ;
</code><code>    tree:node ex:nextNode ;
</code><code>    tree:value &quot;2022-01-03T09:47:59.000000&quot;^^xsd:dateTime ;
</code><code>    tree:path etsi:hasTimestamp 
</code><code>] .
</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> Hypermedia description of a TREE fragment <code>ex:nextNode</code> containing resources having the property <code>etsi:hasTimestamp</code>
respecting the constraint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">?</mo><mi>t</mi><mo>&gt;</mo><mo>=</mo><mtext>2022-01-03T09:47:59.000000</mtext></mrow><annotation encoding="application/x-tex">?t&gt;= \text{2022-01-03T09:47:59.000000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mclose">?</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">2022-01-03T09:47:59.000000</span></span></span></span></span>.</p>
            </figcaption>
</figure>
</div>

      </div>
</section>

  <section id="guided_link_traversal" inlist="" rel="schema:hasPart" resource="#guided_link_traversal">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Pruning links using filter expressions</h2>

        <p>Most research around LTQP has been done on query execution over Linked Open Data <span class="references">[<a href="#ref-6">6</a>]</span>.
Given the pseudo-infinite number of documents on the Web, traversing over all documents is practically infeasible.
To get a grasp on this completeness issue, different reachability criteria <span class="references">[<a href="#ref-9">9</a>]</span> were introduced
that allow certain links not to be followed based on the query that is executed.
Recently, an alternative direction was introduced <span class="references">[<a href="#ref-10">10</a>]</span>
where instead of just looking at the query to determine which links to follow,
the data publisher could <em>guide</em> the engine towards query-relevant links.
This strategy was <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2023-SolidQuery/">applied on the Solid ecosystem</a> <span class="references">[<a href="#ref-7">7</a>]</span>,
exploiting structural properties of Solid to prune links when traversing over Solid vaults.</p>

        <p>Our approach builds upon this concept of guided link traversal,
and similar to the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2023-SolidQuery/">Solid approach</a> <span class="references">[<a href="#ref-7">7</a>]</span>, exploits the structural properties of TREE datasets to prune links.
Concretely, we interpret the hypermedia descriptions of constraints in TREE fragments as boolean equations
as shown in <a href="#TREE-relation-turtle-example">Listing 2</a>.
Upon discovery of a document, the query engine gathers the relevant triples to form a boolean expression
representing the constraint of the next fragment and effectively pushes down the boolean SPARQL filter expression into the engine’s dereferencing component.
After having those two boolean expressions close together they are evaluated to determine if the are satisfied,
in which case,
the IRI targeting the next fragment is added to the link queue following the concept of reachability criterium.</p>

        <p>We have implemented our approach in a fork of the LTQP version of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-11">11</a>]</span> at
<a href="">https:/​/​anonymous.4open.science/pr/3785</a> with an associated demo available at
<a href="">https:/​/​anonymous.4open.science/r/TREE-Solver-LTQP-demo-engine-21FF/</a>.</p>

        <h2 id="experimental-results">Experimental results</h2>

        <p>To evaluate our approach, we executed four queries similar to the one in <a href="#example-sparql">Listing 1</a>.
All queries are available at <a href="https://anonymous.4open.science/r/How-TREE-hypermedia-can-speed-up-Link-Traversal-based-Query-Processing-queries-8BE8/content/code/">https:/​/​anonymous.4open.science/r/How-TREE-hypermedia-can-speed-up-Link-Traversal-based-Query-Processing-queries-8BE8/content/code/</a>.
These queries were executed with two configurations that will be described below.
They were executed over the DAHCC participant 31 dataset (of 487 MB) with a timeout of two minutes.
We fragmented the (same) dataset following the TREE specification with a one-ary tree topology with 100 and 1000 nodes.</p>

        <figure id="results-queries" class="table table-smaller-font">

          <table>
            <thead>
              <tr>
                <th>Fragments</th>
                <th>Query</th>
                <th>Time (ms)</th>
                <th>Req</th>
                <th>Res</th>
                <th>Time-pushdown (ms)</th>
                <th>Req-pushdown</th>
                <th>Res-pushdown</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>100</td>
                <td>Q1</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>8,892</td>
                <td>3</td>
                <td>0</td>
              </tr>
              <tr>
                <td>100</td>
                <td>Q2</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>3,541</td>
                <td>3</td>
                <td>1</td>
              </tr>
              <tr>
                <td>100</td>
                <td>Q3</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>59,274</td>
                <td>8</td>
                <td>8,166</td>
              </tr>
              <tr>
                <td>100</td>
                <td>Q4</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
              </tr>
              <tr>
                <td>1000</td>
                <td>Q1</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>1,171</td>
                <td>3</td>
                <td>0</td>
              </tr>
              <tr>
                <td>1000</td>
                <td>Q2</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>734</td>
                <td>3</td>
                <td>1</td>
              </tr>
              <tr>
                <td>1000</td>
                <td>Q3</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>39,987</td>
                <td>51</td>
                <td>8,166</td>
              </tr>
              <tr>
                <td>1000</td>
                <td>Q4</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
                <td>X</td>
              </tr>
            </tbody>
          </table>

          <figcaption>
            <p><span class="label">Table 1:</span> Result of the query with our different configurations.
X means that the query did not finish before the timeout, <em>Fragment</em> is the number of fragments,
<em>Time</em> is the query execution time, <em>Req</em> The number of HTTP request and <em>Res</em> the number of result. 
The pushdown suffix indicates that the use of the pushdown filter configuration.</p>
          </figcaption>
        </figure>

        <p>In the first configuration we use a reachability criterium where the engine follows each link of the fragmented dataset.
For the second one we use our pushdown filter approach.
As shown in <a href="#results-queries">Table 1</a> no query could be answered below the timeout value by following every fragment.
The reason is the very large size of the dataset to be traversed before executing the joining and solution mapping.
For the configurations with our filter pushdown method, we see that the queries with 1000 fragments perform better than
the one with 100 fragments, particularly when the query has one or zero results. In those cases, the query execution time is almost one order of magnitude lower with the largest number of fragments.
With Q3 we can see that the percentage of reduction is 32%, this lowering of performance might be caused by the observed increase by a factor of 17 of HTTP requests. 
The query Q4 was not able to be answered, with both fragmentations, because it covers a far larger range and hence requires more data to be downloaded and more processing time.</p>

      </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusion</h2>

        <p>Our preliminary results show that our filter-based link pruning approach to LTQP over fragmented RDF documents
can be effective for significantly reducing the number of links to traverse.
This leads to a significantly lower amount of data that needs to be downloaded,
and to an overall lower query execution time.
This work opens the possibility for faster traversal-based query execution over fragmented RDF documents,
provided that the data publisher uses hypermedia descriptions to characterize the fragmentation
in a structured manner.
In future work, we will investigate filter-based link pruning for more expressive filter expressions,
and evaluate the approach more extensively over more diverse datasets and queries, comparing our approach with alternative query interfaces.</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://doi.org/10.1007/978-3-642-41338-4_18" typeof="schema:Article">Buil-Aranda, C., Hogan, A., Umbrich, J., Vandenbussche, P.-Y.: SPARQL Web-Querying Infrastructure: Ready for Action? In: Proceedings 12th ISWC (2013).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#Azzam2021" typeof="schema:Article">Azzam, A., Aebeloe, C., Montoya, G., Keles, I., Polleres, A., Hose, K.: WiseKG: Balanced Access to Web Knowledge Graphs. In: Proceedings of the Web Conference 2021 (2021).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#ColpaertMaterializedTREE" typeof="schema:Article">Colpaert, P.: Building materializable querying interfaces with the TREE hypermedia specification.</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#lancker2021LDS" typeof="schema:Article">Publishing base registries as Linked Data Event Streams. Proceedings 21th ICWE. (2021).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="#thomasFieldingPhdThesis" typeof="schema:Thesis">Fielding, R.T.: Architectural Styles and the Design of Network-based Software Architectures</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#Hartig2016" typeof="schema:Article">Hartig, O., Özsu, M.T.: Walking Without a Map: Ranking-Based Traversal for Querying Linked Data. In: Groth, P., Simperl, E., Gray, A., Sabou, M., Krötzsch, M., Lecue, F., Flöck, F., and Gil, Y. (eds.) The Semantic Web – ISWC 2016. Springer International Publishing</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2023-SolidQuery/" typeof="schema:Article">Taelman, R., Verborgh, R.: Link Traversal Query Processing over Decentralized Environments with Structural Assumptions. In: Proceedings of the 22nd International Semantic Web Conference (2023).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#dahcc_resource" typeof="schema:Article">Bram, S., De Brouwer, M., Stojchevska, M. , Van Der Donckt, J. , Nelis, J. , Ruyssinck, J., van der Herten, J. , Casier, K. , Van Ooteghem, J. , Crombez, P. , De Turck, F. , Van Hoecke, S.  and Ongenae, F.: Data Analytics For Health and Connected Care: Ontology, Knowledge Graph and Applications. In: Published in the proceedings of the sixteenth EAI Pervasive Healthcare conference (2022).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="#hartig2012" typeof="schema:Article">Hartig, O., Freytag, J.-C.: Foundations of Traversal Based Query Execution over Linked Data. In: Conference on Hypertext and Social Media. ACM</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="#verborgh2020" typeof="schema:CreativeWork">Verborgh, R., Taelman, R.: Guided Link-Traversal-Based Query Processing</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings 17th ISWC (2018).</dd>
</dl>
</section>
</footer>



</div>

</body>
</html>

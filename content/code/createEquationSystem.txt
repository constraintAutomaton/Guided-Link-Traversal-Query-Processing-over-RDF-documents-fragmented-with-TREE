fn createDomainSystem(expressions: SolverExpression[]) {
  if (expressions.length === 1) {
    solutionRange = getSolutionRange(expressions[0])
    return {
      chainOperator: [],
      solutionDomain: solutionRange,
    }
  }

  system = new Map()
  // The first expression that has to be evaluated
  firstEquationToEvaluate: [ISolverExpressionRange, ISolverExpressionRange]
  // The last logical operator apply to the first expression to be evaluated
  firstEquationLastOperator = ''

  for (expression in expressions) {
    lastOperator = expression.lastOperator()
    solutionRange = getSolutionRange(expression)

    subDomain = {
      chainOperator: expression.chainOperator,
      solutionDomain: solutionRange,
    }
    lastEquation = system.get(lastOperator)
    if (lastEquation) {
      firstEquationToEvaluate = [ lastEquation, subDomain ]
      firstEquationLastOperator = lastOperator
    } else {
      system.set(lastOperator, subDomain)
    }
  }

  // We delete the fist subDomain to be evaluated from the system of equation because it is a value returned
  system.delete(firstEquationLastOperator)

  return [ system, firstEquationToEvaluate ]
}
@startuml sequenceSolver
actor Actor as comunicaActor
comunicaActor -> TreeExtractorActor: Make a query to a TREE document
TreeExtractorActor -> QueryAndRelationEvaluator: Evaluation if the filter and the query match

alt The query, the ITreeRelation and the filter has the same variables
QueryAndRelationEvaluator -> SolverParser: Send ITreeRelation and Filter object
else The query doesn't match the filter or/and the ITreeRelation
QueryAndRelationEvaluator --> comunicaActor: Return all the ITreeRelation
end

SolverParser -> InputValidator: Send solver object

alt The type match
InputValidator -> DomainSolutionGenerator: Send valid solver object
else The type doesn't match
InputValidator --> comunicaActor: Return all the ITreeRelation
end
DomainSolutionGenerator -> DomainOverlapAnalyser: Send the solution domain of the expressions

alt Can determine if there is an overlap
DomainOverlapAnalyser --> comunicaActor: Indicate if the relation is valid if the domain of the possible solution overlap
else Cannot determine if an overlap exist eg: there is a function in the filter expression
DomainOverlapAnalyser -> Solver: Send the available solution domain
end
Solver --> comunicaActor: Indicate if the relation is valid if a solution has been found using an optimisation solver (newton, brute force ...)


@enduml
